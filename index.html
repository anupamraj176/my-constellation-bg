<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Constellation background</title>
    <style>
      /* Reset and ensure the canvas fills the screen */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        overflow: hidden;
        background: #000;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }
      #constellation-canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }

      /* Center the text overlay */
      .content-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: white;
        z-index: 10;
        pointer-events: none; /* Allows mouse events to pass through to the canvas */
        -webkit-user-select: none;
        user-select: none;
      }
      .logo {
        font-size: 48px;
        font-weight: 600;
        letter-spacing: 10px;
        margin-bottom: 10px;
        text-transform: uppercase;
      }
      .tagline {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.4);
        text-transform: uppercase;
        letter-spacing: 2px;
      }
    </style>
  </head>
  <body>
    <canvas id="constellation-canvas"></canvas>

    <script>
      /**
       * ConstellationBackground Class
       * Manages a particle system of stars, dynamic connections, and meteor animations.
       */
      class ConstellationBackground {
        constructor(canvas, options = {}) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");

          // Default configuration
          this.options = {
            starCount: 20, // Total number of stars
            maxDistance: 50, // Distance at which lines begin to draw between stars
            backgroundColor: "#000000", // Space color
            starColor: "#ffffff", // Base color for stars
            meteorInterval: 3000, // Time in ms between meteor spawns
            ...options,
          };

          // State Management
          this.stars = []; // Array to hold star objects
          this.meteors = []; // Array to hold active meteors
          this.mouse = { x: -1000, y: -1000 }; // Initialize mouse far off-screen
          this.lastMeteorTime = 0; // Timestamp of last meteor spawn
          this.animationId = null;

          this.init();
        }

        /**
         * Initialization sequence
         */
        init() {
          this.resize();
          this.bindEvents();
          this.animate();
        }

        /**
         * Scale canvas to window size and reset star positions
         */
        resize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
          this.initStars();
        }

        /**
         * Generate star objects with randomized properties
         */
        initStars() {
          this.stars = [];
          for (let i = 0; i < this.options.starCount; i++) {
            this.stars.push({
              x: Math.random() * this.canvas.width,
              y: Math.random() * this.canvas.height,
              radius: Math.random() * 1.2 + 0.4, // Randomized star size
              brightness: Math.random() * 0.5 + 0.5, // Base opacity
              blinkSpeed: Math.random() * 0.001 + 0.0005, // How fast it pulses
              blinkOffset: Math.random() * Math.PI * 2, // Random phase so they don't blink in unison
            });
          }
        }

        /**
         * Create a single meteor with a random trajectory
         */
        createMeteor() {
          const startX = Math.random() * this.canvas.width;

          // Example: Change from "Downward Right" to "Downward Left"
          // Subtracting from the angle or using a negative range shifts direction
          const angle = (Math.random() * Math.PI) / 6 - Math.PI / 4;

          const speed = Math.random() * 3 + 4;

          this.meteors.push({
            x: startX,
            y: -50,
            vx: Math.sin(angle) * speed, // Controls horizontal speed/direction
            vy: Math.cos(angle) * speed, // Controls vertical speed/direction
            opacity: 1,
            tail: [],
          });
        }

        /**
         * Event listeners for interactivity and responsiveness
         */
        bindEvents() {
          window.addEventListener("resize", () => this.resize());
          window.addEventListener("mousemove", (e) => {
            this.mouse.x = e.clientX;
            this.mouse.y = e.clientY;
          });
        }

        /**
         * The Core Animation Loop
         */
        animate(currentTime = 0) {
          const { ctx, canvas, options, stars, meteors, mouse } = this;

          // 1. Clear Frame
          ctx.fillStyle = options.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // 2. Meteor Spawning Logic
          if (currentTime - this.lastMeteorTime > options.meteorInterval) {
            this.createMeteor();
            this.lastMeteorTime = currentTime;
          }

          // 3. Render Stars and Lines
          stars.forEach((star, i) => {
            // Calculate blinking effect using Sine wave
            const time = currentTime * star.blinkSpeed + star.blinkOffset;
            const blinkFactor = Math.sin(time) * 0.4 + 0.6; // Values between 0.2 and 1.0

            ctx.beginPath();
            ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${
              star.brightness * blinkFactor
            })`;
            ctx.fill();

            // Mouse-to-Star Connection
            const mDist = Math.hypot(star.x - mouse.x, star.y - mouse.y);
            if (mDist < 160) {
              ctx.beginPath();
              ctx.moveTo(star.x, star.y);
              ctx.lineTo(mouse.x, mouse.y);
              // The closer the mouse, the brighter the line
              ctx.strokeStyle = `rgba(255, 255, 255, ${
                (1 - mDist / 160) * 0.2
              })`;
              ctx.stroke();
            }

            // Star-to-Star Connection (Constellation effect)
            for (let j = i + 1; j < stars.length; j++) {
              const s2 = stars[j];
              const dist = Math.hypot(star.x - s2.x, star.y - s2.y);

              if (dist < options.maxDistance) {
                ctx.beginPath();
                ctx.moveTo(star.x, star.y);
                ctx.lineTo(s2.x, s2.y);
                ctx.strokeStyle = `rgba(255, 255, 255, ${
                  (1 - dist / options.maxDistance) * 0.12
                })`;
                ctx.lineWidth = 0.6;
                ctx.stroke();
              }
            }
          });

          // 4. Render Meteors
          for (let i = meteors.length - 1; i >= 0; i--) {
            const m = meteors[i];
            m.x += m.vx;
            m.y += m.vy;
            m.opacity -= 0.006; // Meteors fade as they travel

            // Add current position to tail
            m.tail.unshift({ x: m.x, y: m.y });
            if (m.tail.length > 25) m.tail.pop();

            // Cleanup if off-screen or invisible
            if (m.opacity <= 0 || m.y > canvas.height + 50) {
              meteors.splice(i, 1);
              continue;
            }

            // Draw Meteor Trail (Segments get thinner and fainter)
            m.tail.forEach((point, j) => {
              const next = m.tail[j + 1];
              if (!next) return;

              ctx.beginPath();
              ctx.moveTo(point.x, point.y);
              ctx.lineTo(next.x, next.y);
              const tailOpacity = m.opacity * (1 - j / m.tail.length);
              ctx.strokeStyle = `rgba(180, 210, 255, ${tailOpacity * 0.6})`;
              ctx.lineWidth = 2 * (1 - j / m.tail.length);
              ctx.stroke();
            });
          }

          // Recursively call next frame
          this.animationId = requestAnimationFrame((t) => this.animate(t));
        }
      }

      // --- EXECUTION ---
      // Target the canvas and initialize the effect
      const canvasElement = document.getElementById("constellation-canvas");
      const backgroundEffect = new ConstellationBackground(canvasElement);
    </script>
  </body>
</html>
